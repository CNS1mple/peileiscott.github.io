[{"categories":["MIT-6.S081"],"content":" 本人实验环境：Ubuntu20.04(其余环境请参考课程主页的配置教程) 更新apt源： sudo apt update \u0026\u0026 sudo apt upgrade 安装必要软件： sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 下载并解压qemu： wget https://download.qemu.org/qemu-5.1.0.tar.xz tar xf qemu-5.1.0.tar.xz 编译qemu： cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" # 此时可能出现下方错误 ERROR: pixman \u003e= 0.21.8 not present. Please install the pixman devel package. # 解决方法 sudo apt install libpixman-1-dev # 解决后继续执行下方命令 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" make sudo make install cd .. 安装riscv64-unknown-elf-gcc： sudo apt install gcc-riscv64-unknown-elf 下载课程代码： git clone git://g.csail.mit.edu/xv6-labs-2020 验证实验环境是否搭建完成： $ riscv64-unknown-elf-gcc --version riscv64-unknown-elf-gcc () 9.3.0 ... $ qemu-system-riscv64 --version QEMU emulator version 4.2.1 ... $ cd xv6-labs-2020 $ git checkout util $ make qemu ... init: starting sh $ 如果上面步骤都没有问题，说明你的实验环境已经成功搭建好了，最后按Ctrl-a再加x退出qemu ","date":"2021-06-12","objectID":"/mit-6.s081-lab-config/:0:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081实验环境搭建","uri":"/mit-6.s081-lab-config/"},{"categories":["LeetCode"],"content":"题目链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/ 写在前面：几乎所有链表题都有迭代和递归两种方法，并且两种方法都应该掌握，因为有时候面试官会要求使用某种特定的方法。 ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:0:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"迭代方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head for { for i := 0; i \u003c k; i++ { // 不足K个直接返回 if right == nil { return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:1:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"递归方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { if head == nil || head.Next == nil || k == 1 { return head } p := head for i := 0; i \u003c k; i++ { // 不足K个直接返回 if p == nil { return head } p = p.Next } // 翻转 [head, p) 之间的K个节点 newHead := reverse(head, p) // 翻转后前K个节点的最后一个节点为 head，指向后续翻转返回的头节点 head.Next = reverseKGroup(p, k) // 返回新的头节点 return newHead } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:2:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"题目拓展 ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"不足K个也翻转 个人认为这个拓展反而让题目变简单了，在这里只给出迭代方法，递归方法可以类似得出。 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 不足K个也翻转 func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head for { for i := 0; i \u003c k; i++ { // 不足K个直接开始翻转并返回结果 if right == nil { pre.Next = reverseBetween(left, right) return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:1","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"从尾部开始计数 思路：先计算链表的长度，从而计算出从哪个节点开始翻转。也可以用栈做，但是那样空间复杂度就为O(n)了，这里就不给出栈的做法了，有兴趣的可以自己试试。 // 从尾部开始计数 func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // n 用来记录链表的长度 p, n := head, 0 for p != nil { n++ p = p.Next } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head // 先让 pre, left, right 定位到第一次翻转的位置 for i := 0; i \u003c n%k; i++ { pre = pre.Next left = left.Next right = right.Next } for { for i := 0; i \u003c k; i++ { // 最后一次翻转时 right 会等于 nil，进入 if 内部进行最后一次翻转，并返回结果 if right == nil { pre.Next = reverseBetween(left, right) return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:2","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"LeetCode相关题：https://leetcode-cn.com/problems/sort-an-array/ ","date":"2021-06-09","objectID":"/sort-algorithms/:0:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"插入排序 func insertionSort(nums []int, left, right int) { for i := left + 1; i \u003c= right; i++ { j, temp := i-1, nums[i] for ; j \u003e= 0 \u0026\u0026 nums[j] \u003e temp; j-- { nums[j+1] = nums[j] } nums[j+1] = temp } } ","date":"2021-06-09","objectID":"/sort-algorithms/:1:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"快速排序 func quickSort(nums []int, left, right int) { if left \u003e= right { return } index := partition(nums, left, right) quickSort(nums, left, index-1) quickSort(nums, index+1, right) } func partition(nums []int, left, right int) int { // 随机选取一个元素作为基准 pos := rand.Intn(right-left+1) + left nums[left], nums[pos] = nums[pos], nums[left] i, j, pivot := left, right, nums[left] for i \u003c j { for i \u003c j \u0026\u0026 nums[j] \u003e= pivot { j-- } for i \u003c j \u0026\u0026 nums[i] \u003c= pivot { i++ } nums[i], nums[j] = nums[j], nums[i] } nums[i], nums[left] = nums[left], nums[i] return i } ","date":"2021-06-09","objectID":"/sort-algorithms/:2:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"归并排序 func mergeSort(nums []int) []int { if len(nums) \u003c= 1 { return nums } mid := len(nums) / 2 left, right := mergeSort(nums[:mid]), mergeSort(nums[mid:]) return mergeTwoArrays(left, right) } func mergeTwoArrays(left, right []int) []int { m, n := len(left), len(right) res := make([]int, m+n) i, j := 0, 0 for i \u003c m \u0026\u0026 j \u003c n { if left[i] \u003c right[j] { res[i+j] = left[i] i++ } else { res[i+j] = right[j] j++ } } for i \u003c m { res[i+j] = left[i] i++ } for j \u003c n { res[i+j] = right[j] j++ } return res } ","date":"2021-06-09","objectID":"/sort-algorithms/:3:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"堆排序 func heapSort(nums []int, left, right int) { for i := right / 2; i \u003e= 0; i-- { sink(nums, i, right) } for i := right; i \u003e left; i-- { nums[i], nums[left] = nums[left], nums[i] sink(nums, left, i-1) } } func sink(nums []int, root, end int) { for { child := 2*root + 1 if child \u003e end { return } if child \u003c end \u0026\u0026 nums[child] \u003c= nums[child+1] { child++ } if nums[root] \u003e nums[child] { return } nums[root], nums[child] = nums[child], nums[root] root = child } } ","date":"2021-06-09","objectID":"/sort-algorithms/:4:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"题目链接：https://leetcode-cn.com/problems/reverse-linked-list/ 写在前面：几乎所有链表题都有迭代和递归两种方法，并且两种方法都应该掌握，因为有时候面试官会要求使用某种特定的方法。 ","date":"2021-06-07","objectID":"/reverse-linked-list/:0:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["LeetCode"],"content":"迭代方法 由于单链表节点中只保留着下一个节点的信息，上一个节点的信息我们是不知道的，而翻转过程中我们需要将当前节点的next指向上一个节点，因此我们在遍历的过程中需要额外用一个指针告诉我们上一个节点；另外当我们修改了当前节点的next值后，我们将无法通过next来获取下一个节点，因此在修改next之前我们要用一个临时变量获取下一个节点。 通过上面分析，我们在代码实现中只需要注意两点即可： 遍历过程中用一个指针pre指向上一个节点 修改当前节点的next之前用一个临时变量获取下一个节点 经过上面的分析过后，不难写出下面代码： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { // 当链表为空或链表只有一个节点时，直接返回 if head == nil || head.Next == nil { return head } // pre 指向上一个节点，由于第一个节点的 next 将指向 nil，因此为了方便我们可以将 pre 初始化为 nil pre, curr := (*ListNode)(nil), head for curr != nil { // 临时变量 next 获取当前节点 curr 的下一个节点 next := curr.Next // 修改当前节点 curr 的 Next 值完成翻转 curr.Next = pre pre = curr curr = next } // 注意此时 curr 已经变成了 nil, pre 指向了原链表的最后一个节点(新链表的头结点) return pre } ","date":"2021-06-07","objectID":"/reverse-linked-list/:1:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["LeetCode"],"content":"递归方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { // 递归终止条件 if head == nil || head.Next == nil { return head } // 翻转以 head 的下一个节点为首的链表，并获取翻转后的链表的头结点 newHead := reverseList(head.Next) // 将 head 的下一个节点指向 head (将上图节点2指向节点1) head.Next.Next = head // 将 head 指向 nil (将上图节点1指向 nil) head.Next = nil // 返回新的头结点 newHead return newHead } ","date":"2021-06-07","objectID":"/reverse-linked-list/:2:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["CMU-15545"],"content":" 写在前面： 此实验可以直接在Mac(Intel chip)环境下运行，但是笔者今年年初入手的是Mac with M1 chip，经过测试后发现此实验并不能直接在M1芯片上运行(同样的还有MIT6.S081课程，最后只能转战Linux，所以购买Mac M1需谨慎。。) 由于国内网络的某些特殊原因，以下实验环境的搭建过程中需要用到科学上网，具体如何操作请自行研究。 ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:0:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["CMU-15545"],"content":"课程主页：CMU-15545 HOMEPAGE ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:1:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["CMU-15545"],"content":"实验环境：Ubuntu20.04(其余环境的搭建过程请参考Github中的README) 从https://github.com/cmu-db/bustub将实验代码fork到个人仓库，然后通过git clone将代码拷贝到本地。 在bustub目录下执行sudo build_support/packages.sh。 可能出现的错误：sudo: build_support/packages.sh command not found 解决办法：执行chmod +x build_support/packages.sh后再执行上面代码即可。 在bustub目录下依次执行以下命令： mkdir build cd build cmake .. make make check-tests 如果上述步骤没有错误，那么恭喜你，实验环境搭建成功，接下来就可以去完成实验了！ ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:2:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["Linux"],"content":" 本文旨在介绍Ubuntu下apt包管理工具的常用命令，在进行Linux开发时作为词典参考。 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:0:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt update sudo apt update 每次下载或更新本地软件时最好先执行apt update指令从服务器更新本地包仓库，从而获取最新版本的软件。 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:1:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt upgrade 将本地软件更新到仓库中最新版本，执行以下指令 # 更新所有软件 sudo apt upgrade 如果只想更新指定软件而非所有软件，执行以下指令 # 找出可更新的软件 apt list --upgradeable # 更新指定的软件 sudo apt upgrade \u003cpackage_1\u003e \u003cpackage_2\u003e ... 有些软件更新时需要输入y/n确认是否安装，如果不想输入的话可以在apt upgrade后面加-y Flag sudo apt upgrade -y 通常为了方便，我们将上面提到的apt update和apt upgrade写在一行 sudo apt update \u0026\u0026 sudo apt upgrade -y ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:2:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt install 安装指令软件，执行以下指令 sudo apt install \u003cpackage_1\u003e \u003cpackage_2\u003e ... 有些软件安装时需要输入y/n确认是否安装，如果不想输入的话可以在apt install后面加-y Flag sudo apt install -y \u003cpackage_1\u003e \u003cpackage_2\u003e ... 默认情况下apt install安装的软件都是最新版本的，如果想安装老版本的软件可以在软件名后面加=version # 安装 mysql-5.7 sudo apt install mysql-server=5.7 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:3:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt remove/purge 删除指定软件，执行以下指令 # apt remove只会删除软件本身，相关配置文件依旧保留 sudo apt remove \u003cpackage_1\u003e \u003cpackage_2\u003e ... # 如果执行了上面的指令后，想要删除相关配置文件，只需要执行下面这条指令即可 sudo apt autoremove # apt purge会将软件和配置信息一起删除 sudo apt purge \u003cpackage_1\u003e \u003cpackage_2\u003e ... ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:4:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt list sudo apt list apt list命令会列出所有的软件，包括仓库中的、已安装的和可更新的软件等，但是不建议直接执行该指令，最好搭配grep命令一起使用 sudo apt list | grep package_name 如果只想查看已下载的软件，执行以下指令 sudo apt list --installed 查看可更新的软件，执行以下指令 sudo apt list --upgradeable ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:5:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt show sudo apt show package_name apt show命令会列出软件的包依赖、版本、大小等等信息 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:6:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"}]