[{"categories":["CS144"],"content":" 实验指导说明：https://cs144.github.io/assignments/lab2.pdf 本实验目的为完成TCP的接收端，调用segment_received()接受TCP包(TCP segment)从而被前面两个lab中实现的byte_stream和stream_reassembler使用，同时调用ackno()和window_size()将ack和win_size返回给发送方，发送方接收到后可以确定接收方是否正确接受到上一个包，以及下一次发送包的大小范围。官方解释如下图： ","date":"2021-06-28","objectID":"/cs144-lab2/:0:0","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":"stream_index (64-bit)和seqno (32-bit)之间的转换 上图为TCP报文格式，其中红色区域为报头部分，共占20个字节，下方的Payload为数据部分。需要注意的是，在TCP包中seqno和ackno只占4个字节，也就是32-bit(原因在实验指导中提到了，有兴趣可以看看)。但是lab1中stream_reassembler写数据时index使用的是64-bit的数据，因此在向stream_reassembler写入数据以及向发送端返回ack之前需要完成相应的转换。 所有细节点都在上图中，absolute seqno和stream index之间的转换比较简单，只需要加一或减一即可，所以本实验我们只需要实现seqno和absolute seqno之间的转换。其中将absolute seqno转换为seqno(wrap()函数)比较简单，这里就不多说了，主要提一下unwrap()函数实现中的细节点。 unwrap()函数中有三个参数：序列号n、最初的序列号isn (initial sequence number)和checkpoint(不知道该怎么翻译。。。) 第一步算出偏移量offset，比如isn = 2^32 - 2, n = 1的话，offset = 1 - (2^32 - 2) = 3，注意这里是32位无符号数的减法。 算出offset后，absolute seqno并不是直接等于offset，而是有很多种可能情况，offset，offset + 2^32，offset + 2 * 2^32，offset + 3 * 2^32等等都有可能，这也是checkpoint存在的必要，我们需要从所有可能的情况中找到离checkpoint最近的那个数。 接下来这步是最关键的一步。我们可以将checkpoint表示成A * 2^32 + B的形式，那么离checkpoint最近的数就只有下面三种情况：(A-1) * 2^32 + offset，A * 2^32 + offset，(A+1) * 2^32 + offset(不明白的话可以在纸上写一写)。因此我们要通过位运算求出A的值，然后判断下三个数哪个离checkpoint最近即可。需要注意的是，当A等于0时，(A-1) * 2^32 + offset是没有意义的，只需要考虑其他两个数就可以了。 代码实现如下： WrappingInt32 wrap(uint64_t n, WrappingInt32 isn) { // DUMMY_CODE(n, isn); return isn + static_cast\u003cuint32_t\u003e(n); } uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) { // DUMMY_CODE(n, isn, checkpoint); uint32_t offset = n.raw_value() - isn.raw_value(); uint64_t mask = static_cast\u003cuint64_t\u003e(UINT32_MAX) \u003c\u003c 32; uint64_t top32 = checkpoint \u0026 mask; uint64_t num1 = (top32 - (1ul \u003c\u003c 32)) + offset; uint64_t abs1 = checkpoint - num1; uint64_t num2 = top32 + offset; uint64_t abs2 = (checkpoint \u003e num2) ? (checkpoint - num2) : (num2 - checkpoint); uint64_t num3 = (top32 + (1ul \u003c\u003c 32)) + offset; uint64_t abs3 = num3 - checkpoint; if (top32 == 0) { return (abs2 \u003c abs3) ? num2 : num3; } if (abs1 \u003c abs2) { return (abs1 \u003c abs3) ? num1 : num3; } return (abs2 \u003c abs3) ? num2 : num3; } ","date":"2021-06-28","objectID":"/cs144-lab2/:1:0","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":"实现TCP接收端 ","date":"2021-06-28","objectID":"/cs144-lab2/:2:0","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":"segment_received() TCP接收端一共需要经过以下几个状态： 最开始处于listen监听状态，等待收到发送方发来的SYN标志数据传输的开始。对应下方代码的 11-13 行。 收到了SYN后进入第二个状态，将接收到的第一个SYN标志位为1的序列号作为isn，设置_syn_recved为true。第一次时不需要将ack转换为stream_index，因为此时stream_index就是0，直接调用stream_reassembler的push_substring()方法即可，但是在判断eof时需要注意第一次也有可能FIN标志位也为1。除了第一次之外，每次都需要计算checkpoint，然后调用unwrap()函数将ackno转换为abs_ackno，最后减一得到stream_index。 收到FIN进入最后一个状态。设置_fin_recved和eof为true，标志数据输入完毕，如果从tcp_receiver到stream_reassembler和byte_stream之间传输没问题的话，byte_stream就应该调用input_ended()停止接受数据了。 代码实现如下： // tcp_receiver.hh WrappingInt32 _isn{WrappingInt32(0)}; bool _syn_recved{false}; bool _fin_recved{false}; // tcp_receiver.cc void TCPReceiver::segment_received(const TCPSegment \u0026seg) { // DUMMY_CODE(seg); const TCPHeader header = seg.header(); if (!_syn_recved \u0026\u0026 !header.syn) { return; } string data = seg.payload().copy(); bool eof = false; // Receive the first SYN if (!_syn_recved \u0026\u0026 header.syn) { _syn_recved = true; _isn = header.seqno; // It's possible that the header have also FIN flag set. if (header.fin) { _fin_recved = true; eof = true; } _reassembler.push_substring(data, 0, eof); return; } // Receive the FIN if (_syn_recved \u0026\u0026 header.fin) { _fin_recved = true; eof = true; } uint64_t checkpoint = stream_out().bytes_written(); uint64_t abs_seqno = unwrap(header.seqno, _isn, checkpoint); uint64_t stream_index = abs_seqno - 1; _reassembler.push_substring(data, stream_index, eof); } ","date":"2021-06-28","objectID":"/cs144-lab2/:2:1","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":"ackno() 接收到数据后，tcp_receiver需要向发送方返回一个ack数据，发送方可以通过这个ack知道tcp_receiver是否成功收到上一个包，而这个ack就等于tcp_receiver下一步要接收的包的首字节。 如果还没有接收到SYN的话，直接返回空数据。 通过已经写入的字节数获取abs_seqno的值。比如在下图中，bytes_written() = 3，而FIN之前，也就是写入的最后的一个字节的abs_seqno就等于3，如果没有FIN的话，那么ack就等于wrap(abs_seqno + 1, isn)；有FIN的话，注意！！！只有当通过FIN标志得到的eof成功传到stream_reassembler和byte_stream后，FIN标志才真正生效了，也即此时byte_stream应该已经调用了input_ended()函数停止接收数据，这时候abs_seqno就不再是3而应该是4了。对应下方代码 11-13 行。 代码实现如下： optional\u003cWrappingInt32\u003e TCPReceiver::ackno() const { // Return empty if no SYN has been received if (!_syn_recved) { return nullopt; } uint64_t abs_seqno = stream_out().bytes_written(); // FIN also accounts for one byte, but make sure that the reassembler // have successfully received the EOF signal and ended the input stream. // Otherwise, something went wrong and The FIN means nothing. if (_fin_recved \u0026\u0026 stream_out().input_ended()) { abs_seqno++; } return optional\u003cWrappingInt32\u003e(wrap(abs_seqno + 1, _isn)); } ","date":"2021-06-28","objectID":"/cs144-lab2/:2:2","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":"window_size() window_size标志着tcp_receiver还能容纳多少数据，从而告诉发送方下次发送数据的范围。通过lab0和lab1知道byte_stream和stream_reassembler其实是共用一个缓冲区的，因此剩余的空间直接调用byte_stream里的remaining_capacity()函数就可以了。 ","date":"2021-06-28","objectID":"/cs144-lab2/:2:3","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":"实验结果截图 ","date":"2021-06-28","objectID":"/cs144-lab2/:3:0","tags":["CS144，计算机网络"],"title":"CS144 lab2 详解","uri":"/cs144-lab2/"},{"categories":["CS144"],"content":" 实验指导说明：https://cs144.github.io/assignments/lab1.pdf 本实验的目的就是将接收方获取到的TCP段(substrings/segments)重组成有序的，不重复的，从而被我们在lab0中实现的byte_stream读取。虽然看起来很简单，但是其中细节还是不少，\u0008写了两天才弄懂实验所有的细节。。。 ","date":"2021-06-26","objectID":"/cs144-lab1/:0:0","tags":["CS144，计算机网络"],"title":"CS144 lab1 详解","uri":"/cs144-lab1/"},{"categories":["CS144"],"content":"实验中的细节点 需要注意，虽然有的substring完成了重组(上图绿色部分)，但是只要没有被byte_stream读取，它还属于stream_assembler的一部分，因此它的大小也是算在capacity中的一部分的。每接收到一个新的substring时，我们都要检查下哪些部分可以进行重组(可能包括之前未被重组的部分，上图红色部分)并且被byte_stream写入。 此外每次新来一个substring的时候需要根据index分情况讨论(具体见代码部分)；另外如果数据有一部分被舍弃掉的话，那么传进来的eof是无效的，这一点应该挺好理解的。总体来说，如果能弄懂下面这个测试用例的话，应该对本实验理解的差不多了。 ReassemblerTestHarness test{8}; test.execute(SubmitSegment{\"abc\", 0}); test.execute(BytesAssembled(3)); test.execute(NotAtEof{}); test.execute(SubmitSegment{\"ghX\", 6}.with_eof(true)); test.execute(BytesAssembled(3)); test.execute(NotAtEof{}); test.execute(SubmitSegment{\"cdefg\", 2}); test.execute(BytesAssembled(8)); test.execute(BytesAvailable{\"abcdefgh\"}); test.execute(NotAtEof{}); ","date":"2021-06-26","objectID":"/cs144-lab1/:1:0","tags":["CS144，计算机网络"],"title":"CS144 lab1 详解","uri":"/cs144-lab1/"},{"categories":["CS144"],"content":"map实现 最开始我用的map来保存substring的，代码如下： stream_reassembler.hh std::map\u003csize_t, char\u003e index2byte{}; bool _eof{false}; size_t _head_index = 0; size_t _unassembled_bytes = 0; ByteStream _output; //!\u003c The reassembled in-order byte stream size_t _capacity; //!\u003c The maximum number of bytes stream_reassembler.cc #include \"stream_reassembler.hh\" // Dummy implementation of a stream reassembler. // For Lab 1, please replace with a real implementation that passes the // automated checks run by `make check_lab1`. // You will need to add private members to the class declaration in `stream_reassembler.hh` // template \u003ctypename... Targs\u003e // void DUMMY_CODE(Targs \u0026\u0026... /* unused */) {} using namespace std; StreamReassembler::StreamReassembler(const size_t capacity) : _output(capacity), _capacity(capacity) {} //! \\details This function accepts a substring (aka a segment) of bytes, //! possibly out-of-order, from the logical stream, and assembles any newly //! contiguous substrings and writes them into the output stream in order. void StreamReassembler::push_substring(const string \u0026data, const size_t index, const bool eof) { // DUMMY_CODE(data, index, eof); if (index \u003e= _head_index + _output.remaining_capacity()) { return; } if (index + data.size() \u003c _head_index) { if (eof \u0026\u0026 empty()) { _output.end_input(); } return; } bool flag = true; if (index + data.size() \u003e _head_index + _output.remaining_capacity()) { flag = false; } // size_t count = 0; for (size_t i = index; i \u003c index + data.size() \u0026\u0026 i \u003c _head_index + _output.remaining_capacity(); i++) { if (i \u003e= _head_index \u0026\u0026 index2byte.find(i) == index2byte.end()) { index2byte[i] = data[i - index]; // count++; _unassembled_bytes++; } } string str = \"\"; for (size_t i = _head_index; index2byte.find(i) != index2byte.end(); i++) { str += index2byte[i]; index2byte.erase(i); _head_index++; _unassembled_bytes--; } _output.write(str); if (flag \u0026\u0026 eof) { _eof = true; } if (_eof \u0026\u0026 empty()) { _output.end_input(); } } size_t StreamReassembler::unassembled_bytes() const { return _unassembled_bytes; } bool StreamReassembler::empty() const { return unassembled_bytes() == 0; } 测试结果(见下图)并不是太理想，虽然实验指导中说了不用过分追求效率，但是也给出了一个预期结果，就是每个测试用时不超过半秒。 ","date":"2021-06-26","objectID":"/cs144-lab1/:2:0","tags":["CS144，计算机网络"],"title":"CS144 lab1 详解","uri":"/cs144-lab1/"},{"categories":["CS144"],"content":"deque实现 map实现中其实并没用到map的很多性质，只用来作为存放bytes的容器并且判断某个索引位置是否有数据。这样的话完全就可以换成数组之类的容器，同时用一个bitmap来标志某个位置是否有数据即可，最后我采用的是deque数据结构，其实只要满足先进先出的数据结构都可以。最后代码如下： stream_reassembler.hh std::deque\u003cchar\u003e _buf; std::deque\u003cbool\u003e _bitmap; bool _eof{false}; size_t _head_index = 0; size_t _unassembled_bytes = 0; ByteStream _output; //!\u003c The reassembled in-order byte stream size_t _capacity; //!\u003c The maximum number of bytes stream_reassembler.cc #include \"stream_reassembler.hh\" // Dummy implementation of a stream reassembler. // For Lab 1, please replace with a real implementation that passes the // automated checks run by `make check_lab1`. // You will need to add private members to the class declaration in `stream_reassembler.hh` // template \u003ctypename... Targs\u003e // void DUMMY_CODE(Targs \u0026\u0026... /* unused */) {} using namespace std; StreamReassembler::StreamReassembler(const size_t capacity) : _buf(capacity, '\\0'), _bitmap(capacity, false), _output(capacity), _capacity(capacity) {} //! \\details This function accepts a substring (aka a segment) of bytes, //! possibly out-of-order, from the logical stream, and assembles any newly //! contiguous substrings and writes them into the output stream in order. void StreamReassembler::push_substring(const string \u0026data, const size_t index, const bool eof) { // DUMMY_CODE(data, index, eof); if (index \u003e= _head_index + _output.remaining_capacity()) { return; } if (index + data.size() \u003c _head_index) { if (eof) { _eof = true; } } else { if (index + data.size() \u003c= _head_index + _output.remaining_capacity()) { if (eof) { _eof = true; } } for (size_t i = index; i \u003c _head_index + _output.remaining_capacity() \u0026\u0026 i \u003c index + data.size(); i++) { if (i \u003e= _head_index \u0026\u0026 !_bitmap[i - _head_index]) { _buf[i - _head_index] = data[i - index]; _bitmap[i - _head_index] = true; _unassembled_bytes++; } } string str = \"\"; while (_bitmap.front()) { str += _buf.front(); _buf.pop_front(); _buf.push_back('\\0'); _bitmap.pop_front(); _bitmap.push_back(false); } size_t len = str.size(); if (len \u003e 0) { _unassembled_bytes -= len; _head_index += len; _output.write(str); } } if (_eof \u0026\u0026 empty()) { _output.end_input(); } } size_t StreamReassembler::unassembled_bytes() const { return _unassembled_bytes; } bool StreamReassembler::empty() const { return unassembled_bytes() == 0; } 最后测试结果(见下图)也基本达到了预期结果，所有测试的用时加起来也才到一秒钟。 ","date":"2021-06-26","objectID":"/cs144-lab1/:3:0","tags":["CS144，计算机网络"],"title":"CS144 lab1 详解","uri":"/cs144-lab1/"},{"categories":["CS144"],"content":" 实验指导说明：https://cs144.github.io/assignments/lab0.pdf ","date":"2021-06-23","objectID":"/cs144-lab0/:0:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"build prerequisite 本人实验环境：阿里云服务器 Ubuntu20.04，其余环境的配置请参考官方提供的实验环境配置指导。 实验前需要下载以下软件： g++ (version \u003e 8) clang-tidy (version = 6或7) clang-format (version = 6或7) 其中本人下载的为 clang-tidy-7 和 clang-format-7。 cmake (version \u003e= 3) libpcap-dev git iptables mininet (version \u003e= 2.2.0) tcpdump telnet wireshark socat netcat-openbsd GNU coreutils bash doxygen graphviz 可以通过apt list --installed | grep \u003csoftware_name\u003e查看缺少哪些软件，然后再运行sudo apt install \u003csoftware_name\u003e安装即可。 ","date":"2021-06-23","objectID":"/cs144-lab0/:1:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"Fetch a Web page 使用浏览器访问http://cs144.keithw.org/hello，发现只有一行文字：Hello, CS144!。在命令行中输入telnet cs144.keithw.org http，得到结果如下图： 随后依次输入： GET /hello HTTP/1.1并敲入回车。这一行指令表示向服务器发送在HTTP/1.1下获取路径为/hello的数据的请求。 Host: cs144.keithw.org并敲入回车。这一行指令告诉服务器host地址。 Connection: close并敲入回车。这一行指令告诉服务器客户的请求已经发送完毕，服务器只要发送完数据就可以断开连接。 注意此时还需要敲一下回车。 如果一切都顺利的话，应该能看到下图中的结果： ","date":"2021-06-23","objectID":"/cs144-lab0/:2:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"Send yourself an email 这个由于没有官方账号，用QQ邮箱测试也一直连接不上，故跳过。 ","date":"2021-06-23","objectID":"/cs144-lab0/:3:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"Listening and connecting 打开两个终端，其中一个终端输入netcat -lnvp 9090创建服务器开启监听，如下图： 另一个终端输入telnet localhost 9090连接服务器，如下图： 同时另一个终端显示Connection received on 127.0.0.1 50436，表示已经连接成功。然后在任意一个窗口输入内容，可以发现另一个窗口显示同样的内容，说明数据成功地在服务器和客户端之间传输。 ","date":"2021-06-23","objectID":"/cs144-lab0/:4:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"fetching and building the starter code git clone https://github.com/cs144/sponge cd sponge mkdir build cd build # 由于本人前面安装的为 clang-tidy-7 和 clang-format-7，故此时需要进行相应设置 CLANG_TIDY=clang-tidy-7 CLANG_FORMAT=clang-foramt-7 cmake .. make ","date":"2021-06-23","objectID":"/cs144-lab0/:5:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"Writing webget 在正式敲代码之前务必仔细阅读实验指导中对C++的要求和说明以及libsponge/util/file descriptor.hh，libsponge/util/socket.hh，libsponge/util/address.hh。 本实验的目的就是完成webget.cc中的get_URL函数，实现对网页数据的获取。首先阅读下doctests/socket_example_2.cc中是如何创建TCPSocket以及建立连接，发送并读取数据。再了解了相关API后，我们只需要依次进行以下操作： 创建一个TCPSocket并与服务器建立连接。 向服务器发送请求，格式参照前面fetch a web page部分，注意在HTTP中每行的结尾应该为\\r\\n。 发送完请求后，客户端应该关闭TCPSocket的写功能，对应前面的Connection: close，告诉服务器请求已经发送完毕，服务器只要回复完数据后就可以立刻断开连接。 循环读取从服务器发送过来的信息，直到遇到EOF (end of file)。 最后记得需要关闭前面创建的TCPSocket。 最终代码实现如下： void get_URL(const string \u0026host, const string \u0026path) { // Your code here. // You will need to connect to the \"http\" service on // the computer whose name is in the \"host\" string, // then request the URL path given in the \"path\" string. // Create a TCP socket and connect to the \"http\" service on host TCPSocket socket; socket.connect(Address(host, \"http\")); // Then you'll need to print out everything the server sends back, // (not just one call to read() -- everything) until you reach // the \"eof\" (end of file). // Send HTTP request to the server socket.write(\"GET \" + path + \" HTTP/1.1\\r\\nHost: \" + host + \"\\r\\n\\r\\n\"); // Tell the server that it's not going to send any more requests socket.shutdown(SHUT_WR); // Print out everything the server sends back while (!socket.eof()) { cout \u003c\u003c socket.read(); } // Close the socket socket.close(); // cerr \u003c\u003c \"Function called: get_URL(\" \u003c\u003c host \u003c\u003c \", \" \u003c\u003c path \u003c\u003c \").\\n\"; // cerr \u003c\u003c \"Warning: get_URL() has not been implemented yet.\\n\"; } 在build目录下执行make，通过运行./apps/webget cs144.keithw.org /hello和make check_webget来验证代码正确性。 ","date":"2021-06-23","objectID":"/cs144-lab0/:6:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["CS144"],"content":"An in-memory reliable byte stream 简单来说，就是要实现一个用来支持给输入端写入数据和输出端读取数据的字节流缓冲区。由于缓存区的数据需要满足先进先出的原则，这里我采用的是deque(也可以使用queue)，同时根据提示以及类中函数说明，我们还需要定义几个变量：缓存区的容量、输入端是否写入完毕、以及写入和读取的字节数。变量定义代码如下： size_t _capacity = 0; std::deque\u003cchar\u003e _buf{}; bool _end_input = false; size_t _bytes_written = 0; size_t _bytes_read = 0; 函数实现代码如下： ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {} size_t ByteStream::write(const string \u0026data) { if (remaining_capacity() == 0) { return 0; } size_t len2write = min(remaining_capacity(), data.size()); for (size_t i = 0; i \u003c len2write; i++) { _buf.push_back(data[i]); } _bytes_written += len2write; return len2write; } //! \\param[in] len bytes will be copied from the output side of the buffer string ByteStream::peek_output(const size_t len) const { size_t len2peek = min(buffer_size(), len); return string().assign(_buf.begin(), _buf.begin() + len2peek); } //! \\param[in] len bytes will be removed from the output side of the buffer void ByteStream::pop_output(const size_t len) { size_t len2pop = min(buffer_size(), len); for (size_t i = 0; i \u003c len2pop; i++) { _buf.pop_front(); } _bytes_read += len2pop; } //! Read (i.e., copy and then pop) the next \"len\" bytes of the stream //! \\param[in] len bytes will be popped and returned //! \\returns a string std::string ByteStream::read(const size_t len) { string ret = peek_output(len); pop_output(len); return ret; } void ByteStream::end_input() { _end_input = true; } bool ByteStream::input_ended() const { return _end_input; } size_t ByteStream::buffer_size() const { return _buf.size(); } bool ByteStream::buffer_empty() const { return buffer_size() == 0; } bool ByteStream::eof() const { return _end_input \u0026\u0026 (buffer_size() == 0); } size_t ByteStream::bytes_written() const { return _bytes_written; } size_t ByteStream::bytes_read() const { return _bytes_read; } size_t ByteStream::remaining_capacity() const { return _capacity - _buf.size(); } 在build目录下执行make，通过运行make check_lab0验证代码正确性。记得最后运行make format将代码格式化。 ","date":"2021-06-23","objectID":"/cs144-lab0/:7:0","tags":["CS144","计算机网络"],"title":"CS144 lab0 详解","uri":"/cs144-lab0/"},{"categories":["MIT-6.S081"],"content":" LAB链接：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html ","date":"2021-06-18","objectID":"/mit-6.s081-lab2-syscall/:0:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab2-syscall 详解","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["MIT-6.S081"],"content":"System call tracing 实验说明：trace接受一个整数mask，如果这个mask的二进制表示下某一位为1，该进程及其子进程在执行系统调用时如果使用到了对应的系统调用，就会打印进程的编号pid，该系统调用的名字name以及返回值return value。 其中系统调用的编号定义在kernel/syscall.h中，在最后添加一行#define SYS_trace 22方便我们后面输出trace，代码如下： // System call numbers #define SYS_fork 1 #define SYS_exit 2 #define SYS_wait 3 #define SYS_pipe 4 #define SYS_read 5 #define SYS_kill 6 #define SYS_exec 7 #define SYS_fstat 8 #define SYS_chdir 9 #define SYS_dup 10 #define SYS_getpid 11 #define SYS_sbrk 12 #define SYS_sleep 13 #define SYS_uptime 14 #define SYS_open 15 #define SYS_write 16 #define SYS_mknod 17 #define SYS_unlink 18 #define SYS_link 19 #define SYS_mkdir 20 #define SYS_close 21 #define SYS_trace 22 当trace传入的参数mask为32时，因为32 = 1 \u003c\u003c 5，只有第五位为1，从而在系统调用跟踪时只会输出read相应的内容，其中一个例子如下： $ trace 32 grep hello README 3: syscall read -\u003e 1023 3: syscall read -\u003e 966 3: syscall read -\u003e 70 3: syscall read -\u003e 0 $ 明白了题目意思后，但是代码层面还是不知道该怎么下手。别担心，跟着官网给的提示一步步来： 将$U/_trace\\写入Makefile中的UPROGS。 执行make qemu后发现编译器无法编译user/trace.c中trace()函数。往user/user.h中添加trace系统函数的原型prototype，往user/usys.pl中添加trace系统调用代码生成指令调用，往kernel/syscall.h中添加trace系统调用编号。此时就可以成功执行make qemu，因为我们还没有具体实现该系统调用，当运行trace 32 grep hello README后报错。 在kernel/proc.h的proc结构体中添加一个新变量trace_mask，在kernel/sysproc.c中添加一个sys_trace()函数用于获取trace系统调用传入的mask并且保存在该进程的trace_mask中。 向kernel/proc.c中的fork()函数中添加一行代码np-\u003etrace_mask = p-\u003etrace_mask;，将父进程的trace mask复制到子进程中。 修改kernel/syscall.c中syscall()函数打印追踪路径，同时需要添加一个包含系统调用名字的字符串数组syscall_names。此外，还需要将新添加的sys_trace加入到全局函数声明和syscalls数组中。 具体代码修改见 GitHub Commit 最后运行./grade-lab-syscall trace验证代码正确性。(其中有个别测试需要时间较长，需耐心等待一会) ","date":"2021-06-18","objectID":"/mit-6.s081-lab2-syscall/:1:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab2-syscall 详解","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["MIT-6.S081"],"content":"Sysinfo 将$U\\_sysinfotest\\写入Makefile中的UPROGS。 添加新的系统调用sysinfo的过程和前面的trace一致，这里就不再赘述。 在kernel/sysproc.c中添加一个sys_sysinfo()函数用于将空闲内存freemem和进程数量nproc等系统信息sysinfo从内核拷贝回用户空间，其中获取freemem和nproc需要添加对应的函数，如何使用copyout函数需要参照kernel/sysfile.c中的sys_fstat()函数和kernel/file.c中的filestat()函数。 在kernel/kalloc.c中添加一个函数kfree_memory()用来获取空闲内存的大小。通过分析kalloc.c中的代码发现内核中维护着一个空闲链表freelist，链表的每个节点对应PGSIZE(4K)大小的空闲内存，通过遍历freelist很容易得到剩余空闲内存的大小。 在kernel/proc.c中添加一个函数proc_count()函数用来获取状态不是UNUSED的进程的数量。不难发现，在proc.c中所有进程保存在proc[NPROC]数组中，遍历该数组统计出状态不是UNUSED的进程的数量即可。 添加完两个函数后，执行make qemu编译器指出sysproc.c中并没有引入两个函数原型，阅读xv6 book第二章的第4节发现内核中所有的函数声明都在kernel/defs.h头文件中。因此在defs.h中对应位置添加两个函数原型即可。 具体代码修改见 GitHub Commit 最后运行./grade-lab-syscall sysinfo验证代码正确性。 最后创建一个time.txt并写入一个数字表示你完成实验所花的时间，执行make grade，如果显示分数为35/35，说明实验全部做完啦~ ","date":"2021-06-18","objectID":"/mit-6.s081-lab2-syscall/:2:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab2-syscall 详解","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["MIT-6.S081"],"content":" LAB链接：https://pdos.csail.mit.edu/6.S081/2020/labs/util.html ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:0:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"sleep 作为第一个lab的第一个练习，主要用来给我们熟悉下代码框架和c语言的库函数等。 如果对进程调度和系统调用不熟悉的话请先看xv6 book第一章的第一节。 根据提示，查看user/echo.c, user/grep.c, user/rm.c源码了解如何获取并使用命令行参数(如果你熟悉c语言的话应该早已了解)，即main函数中传入了两个参数argc和argv，其中agrc表示命令行参数的个数(argument count)，argv表示命令行向量(argument vector)。例如有个可执行程序argstest，当你执行./argstest 1 2 3时，argc为4，argv为{\"argstest\", \"1\", \"2\", \"3\", NULL}，注意c语言中最后需要NULL作为终结符。 知道了命令行参数相关知识之后，根据sleep的参数个数argc应该为2(一个为sleep，另一个为用户指定的睡眠时间)，如果不为2，输出错误信息并退出。 通过atoi库函数将字符串转化为整数。其中atoi代表Ascii to Integer。 调用系统调用sleep。至于内核中如何实现系统调用sleep，可以查看kernel/sysproc.c中的sys_sleep函数；系统调用sleep从用户态跳到内核态的过程，可以查看user/usys.S中的相关汇编代码(本人太菜看不懂…) 最后将sleep写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" int main(int argc, char *argv[]) { if (argc != 2) { fprintf(2, \"Usage: sleep \u003cnumber\u003e\\n\"); exit(1); } int i = atoi(argv[1]); sleep(i); exit(0); } 运行sleep指令： $ make qemu ... init: starting sh $ sleep 10 (大概睡眠1秒) $ 执行./grade-lab-util sleep验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:1:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"pingpong 如果对I/O，文件描述符以及管道知识不熟悉的话请先看xv6 book第一章的第二、三节。 首先根据pingpong的使用，如果参数的个数大于1，直接输出错误信息并退出。 使用pipe()系统调用创建两个管道，将描述符存放在p1[2]和p2[2]，父进程向p1写，从p2读；子进程从p1读，向p2写。 父进程和子进程的读写顺序：不使用wait()的情况下父进程应该先写后读，子进程应该先读后写。 父进程不需要用到p1的读端和p2的写端，因此直接调用close()关闭，然后向p1写入一个字节内容，写完后关闭p1的写端，最后从p2读取内容，如果读取的字节数正好为1，则输出响应信息并关闭p2读端。子进程执行类似操作。 最后将pingpong写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" // Read and Write end of a pipe #define READ_END 0 #define WRITE_END 1 int main(int argc, char *argv[]) { if (argc \u003e 1) { fprintf(2, \"Usage: pingpong\\n\"); exit(1); } // Create two pipes: p1 and p2 // Child reads from p1, writes to p2 // Parent reads from p2, writes to p1 int p1[2], p2[2]; pipe(p1); pipe(p2); char buf[1]; if (fork() == 0) { // Child should read first close(p1[WRITE_END]); close(p2[READ_END]); if (read(p1[READ_END], buf, 1) == 1) { close(p1[READ_END]); printf(\"%d: received ping\\n\", getpid()); } // Child sends a byte to parent write(p2[WRITE_END], buf, 1); close(p2[WRITE_END]); } else { // Parent should write first close(p1[READ_END]); close(p2[WRITE_END]); // Parent sends a byte to child write(p1[WRITE_END], buf, 1); close(p1[WRITE_END]); if (read(p2[READ_END], buf, 1) == 1) { close(p2[READ_END]); printf(\"%d: received pong\\n\", getpid()); } } exit(0); } 运行pingpong指令： $ make qemu ... init: starting sh $ pingpong 4: received ping 3: received pong $ 运行./grade-lab-util pingpong验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:2:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"primes 首先通过阅读this page了解primes的工作原理：创建一个管道，父进程向管道写入从2到35的整数，子进程从管道读取数据后输出2，并且再次创建一个管道，向新创建的管道写入不是2的倍数的所有数字，依次递归进行下去，直到最后管道里没有任何数据。具体如下图： 根据primes的使用，如果参数的个数大于1，直接输出错误信息并退出。 main函数中，创建一个管道，父进程中先关闭管道的读端，然后向管道写入从2到35的整数，最后关闭管道的写端，注意此时需要执行wait()系统调用等待子进程执行完毕，否则父进程会在向管道写完数据后直接退出；子进程调用child()函数执行响应的操作。 child()函数中，首先关闭父进程中创建的管道pp的写端，从pp中读入一个int大小的数据，如果read()返回0，说明管道中没有数据，关闭pp的读端后直接返回；反之，输出从pp中读取到的第一个数i，随后创建当前进程的管道cp，在当前进程中关闭cp的读端后循环向cp中写入所有不是i的倍数，最后关闭pp的读端和cp的写端，调用wait()等待子进程；当前进程的子进程中，关闭pp的读端和cp的写端后，递归调用child()函数。 最后将primes写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" // Read and Write end of a pipe #define READ_END 0 #define WRITE_END 1 // pp, cp stands for parent pipe and child pipe, respectively void child(int pp[]) { close(pp[WRITE_END]); int i; if (read(pp[READ_END], \u0026i, sizeof(i)) == 0) { close(pp[READ_END]); exit(0); } printf(\"prime %d\\n\", i); int num, cp[2]; pipe(cp); if (fork() == 0) { close(pp[READ_END]); close(cp[WRITE_END]); child(cp); } else { close(cp[READ_END]); while (read(pp[READ_END], \u0026num, sizeof(num)) != 0) { if (num % i != 0) { write(cp[WRITE_END], \u0026num, sizeof(num)); } } close(pp[READ_END]); close(cp[WRITE_END]); wait((int *) 0); } exit(0); } int main(int argc, char *argv[]) { if (argc \u003e 1) { fprintf(2, \"Usage: primes\\n\"); exit(1); } int p[2]; pipe(p); if (fork() == 0) { child(p); } else { close(p[READ_END]); // Feed the numbers 2 through 35 into the pipe for (int i = 2; i \u003c= 35; i++) { write(p[WRITE_END], \u0026i, sizeof(i)); } close(p[WRITE_END]); wait((int *) 0); } exit(0); } 运行primes指令： $ make qemu ... init: starting sh $ primes prime 2 prime 3 prime 5 prime 7 prime 11 prime 13 prime 17 prime 19 prime 23 prime 29 prime 31 $ 运行./grade-lab-util primes验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:3:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"find 如果对文件系统相关知识不熟悉的话请先看xv6 book第一章的第四节。 首先阅读user/ls.c源码了解如何读取文件目录信息以及判断文件类型，对ls.c的分析见下方代码中注释。 #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\" char* fmtname(char *path) { // DIRSIZ 在`kernel/fs.h`中定义 // #define DIRSIZ 14 static char buf[DIRSIZ+1]; char *p; // Find first character after last slash. for(p=path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; // 此时 p 为最后一个 \"/\" 后的字符串，即文件名。例如当路径为\"a/b/cd\"时，此时p为\"cd\" // Return blank-padded name. // 如果 p 的长度大于 DIRSIZ，直接返回 p if(strlen(p) \u003e= DIRSIZ) return p; // 如果 p 的长度小于 DIRSIZ，则用空格补齐 memmove(buf, p, strlen(p)); memset(buf+strlen(p), ' ', DIRSIZ-strlen(p)); return buf; } void ls(char *path) { char buf[512], *p; int fd; // 文件描述符 file descriptor // 定义位于 kernel/fs.h struct dirent de; // 目录项 directory entry // 定义位于 kernel/stat.h struct stat st; // 文件信息 file status // 调用 open() 打开路径 path 并返回相应的文件描述符 fd if((fd = open(path, 0)) \u003c 0){ fprintf(2, \"ls: cannot open %s\\n\", path); return; } // 调用 fstat 将 fd 对应的文件信息记录在 st 中 if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"ls: cannot stat %s\\n\", path); close(fd); return; } switch(st.type){ // st.type 为文件时直接返回即可 case T_FILE: printf(\"%s %d %d %l\\n\", fmtname(path), st.type, st.ino, st.size); break; // 当 st.type 为目录时 case T_DIR: // 此处只是限制了路径 path 的长度防止缓存溢出，不是很重要可以忽略 if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"ls: path too long\\n\"); break; } // 将 path 的内容拷贝到 buf strcpy(buf, path); // 指针 p 定位到 buf 的最后 p = buf+strlen(buf); // 在 buf 的最后位置添加 \"/\" *p++ = '/'; // 每次读取一个目录项 while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ // inum == 0 说明无效文件或目录 if(de.inum == 0) continue; // 将 de.name 拷贝到 p 中 memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, \u0026st) \u003c 0){ printf(\"ls: cannot stat %s\\n\", buf); continue; } printf(\"%s %d %d %d\\n\", fmtname(buf), st.type, st.ino, st.size); } break; } // 最后别忘了关闭文件描述符，否则浪费资源 close(fd); } int main(int argc, char *argv[]) { int i; // 如果 ls 后面没有参数，默认对当前目录 \".\" 执行 ls 命令 if(argc \u003c 2){ ls(\".\"); exit(0); } // 对 ls 后面的目录分别执行 ls 命令 for(i=1; i\u003cargc; i++) ls(argv[i]); exit(0); } 根据find的使用，参数的个数应该为3，分别是find、指定目录path、指定文件名filename。 递归调用find进入子目录寻找，注意不要进入\".“和”..“目录。 使用strcmp()函数判断两个字符串是否相等。 将find写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\" char* fmtname(char *path) { char *p; // Find first character after last slash for (p = path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; return p; } void find(char *path, char *filename) { char buf[512], *p; int fd; // file descriptor struct dirent de; // directory entry struct stat st; // file status if ((fd = open(path, 0)) \u003c 0) { fprintf(2, \"find: cannot open %s\\n\", path); return; } if (fstat(fd, \u0026st) \u003c 0) { fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } switch (st.type) { case T_FILE: if (strcmp(fmtname(path), filename) == 0) { printf(\"%s\\n\", path); } break; case T_DIR: if (strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf) { printf(\"find: path too long\\n\"); break; } // Add '/' strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while (read(fd, \u0026de, sizeof(de)) == sizeof(de)) { // Invalid directory if (de.inum == 0) { continue; } // Should not recurse into \".\" or \"..\" if (strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) { continue; } memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // Call find recursively find(buf, filename); } break; } close(fd); } int main(int argc, char *argv[]) { if (argc != 3) { fprintf(2, \"Usage: find \u003cpath\u003e \u003cfilename\u003e\\n\"); exit(1); } find(argv[1], argv[2]); exit(0); } 运行find指令： $ make qemu ... init: starting sh $ echo \u003e b $ mkdir a $ echo \u003e a/b $ find . b ./b ./a/b $ 运行./grade-lab-util find验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:4:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"xargs 如果不熟悉xargs指令可以查看xargs命令。 首先要知道，我们要实现的xargs每行只从标准输入流获取一个额外的命令参数。功能类似下图： 根据xargs的使用，参数的个数至少为2个，xargs、指定的命令command。 kernel/param.h中定义了最大参数个数MAXARG，创建一个大小为MAXARG的数组params用于存放命令参数，将argv中相应的参数拷贝到到params，注意留一个位置用于存放从标准输入读取的那个额外的命令参数。 从标准输入循环读取命令参数，当遇到\\n说明当前行的参数已经读取完毕，将其存放入params后创建一个子进程调用exec()执行对应的指令；如果标准输入中的参数读取完毕，则退出循环。注意父进程中调用wait()等待子进程结束。 最后将xargs写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\"#include \"kernel/param.h\" int main(int argc, char *argv[]) { if (argc \u003c 2) { fprintf(2, \"Usage: xargs \u003ccommand\u003e\\n\"); exit(1); } char *cmd = argv[1]; char *params[MAXARG], buf[512]; int i; if (argc + 1 \u003e MAXARG) { fprintf(2, \"Too many arguments\\n\"); exit(1); } for (i = 1; i \u003c argc; i++) { params[i-1] = argv[i]; } // params[argc-1] is the command argument from standard input // params[argc] is the NULL termination params[argc] = 0; while (1) { i = 0; while (1) { int n = read(0, \u0026buf[i], 1); // n == 0 means it reaches the end of the argument from standard input // buf[i] == '\\n' means it reaches the end of current line if (n == 0 || buf[i] == '\\n') break; i++; } // i == 0 means there's nothing left to be read if (i == 0) break; buf[i] = 0; params[argc-1] = buf; if (fork() == 0) { exec(cmd, params); exit(0); } else { // Wait for the child to complete the command wait((int *) 0); } } exit(0); } 运行xargs指令： $ make qemu ... init: starting sh $ sh \u003c xargstest.sh $ $ $ $ $ $ hello hello hello $ $ 运行./grade-lab-util xargs验证代码正确性。 最后创建一个time.txt并写入一个数字表示你完成实验所花的时间，执行make grade，如果显示分数为100/100，说明实验全部做完啦~ ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:5:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":" 本人实验环境：Ubuntu20.04(其余环境请参考课程主页的配置教程) 更新apt源： sudo apt update \u0026\u0026 sudo apt upgrade 安装必要软件： sudo apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 下载并解压qemu： wget https://download.qemu.org/qemu-5.1.0.tar.xz tar xf qemu-5.1.0.tar.xz 编译qemu： cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" # 此时可能出现下方错误 ERROR: pixman \u003e= 0.21.8 not present. Please install the pixman devel package. # 解决方法 sudo apt install libpixman-1-dev # 解决后继续执行下方命令 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" make sudo make install cd .. 安装riscv64-unknown-elf-gcc： sudo apt install gcc-riscv64-unknown-elf 下载课程代码： git clone git://g.csail.mit.edu/xv6-labs-2020 验证实验环境是否搭建完成： $ riscv64-unknown-elf-gcc --version riscv64-unknown-elf-gcc () 9.3.0 ... $ qemu-system-riscv64 --version QEMU emulator version 4.2.1 ... $ cd xv6-labs-2020 $ git checkout util $ make qemu ... init: starting sh $ 如果上面步骤都没有问题，说明你的实验环境已经成功搭建好了，最后按Ctrl-a再加x退出qemu ","date":"2021-06-12","objectID":"/mit-6.s081-lab-config/:0:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081实验环境搭建","uri":"/mit-6.s081-lab-config/"},{"categories":["LeetCode"],"content":"题目链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/ 写在前面：几乎所有链表题都有迭代和递归两种方法，并且两种方法都应该掌握，因为有时候面试官会要求使用某种特定的方法。 ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:0:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"迭代方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head for { for i := 0; i \u003c k; i++ { // 不足K个直接返回 if right == nil { return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:1:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"递归方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { if head == nil || head.Next == nil || k == 1 { return head } p := head for i := 0; i \u003c k; i++ { // 不足K个直接返回 if p == nil { return head } p = p.Next } // 翻转 [head, p) 之间的K个节点 newHead := reverse(head, p) // 翻转后前K个节点的最后一个节点为 head，指向后续翻转返回的头节点 head.Next = reverseKGroup(p, k) // 返回新的头节点 return newHead } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:2:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"题目拓展 ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"不足K个也翻转 个人认为这个拓展反而让题目变简单了，在这里只给出迭代方法，递归方法可以类似得出。 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 不足K个也翻转 func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head for { for i := 0; i \u003c k; i++ { // 不足K个直接开始翻转并返回结果 if right == nil { pre.Next = reverseBetween(left, right) return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:1","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"从尾部开始计数 思路：先计算链表的长度，从而计算出从哪个节点开始翻转。也可以用栈做，但是那样空间复杂度就为O(n)了，这里就不给出栈的做法了，有兴趣的可以自己试试。 // 从尾部开始计数 func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // n 用来记录链表的长度 p, n := head, 0 for p != nil { n++ p = p.Next } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head // 先让 pre, left, right 定位到第一次翻转的位置 for i := 0; i \u003c n%k; i++ { pre = pre.Next left = left.Next right = right.Next } for { for i := 0; i \u003c k; i++ { // 最后一次翻转时 right 会等于 nil，进入 if 内部进行最后一次翻转，并返回结果 if right == nil { pre.Next = reverseBetween(left, right) return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:2","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"LeetCode相关题：https://leetcode-cn.com/problems/sort-an-array/ ","date":"2021-06-09","objectID":"/sort-algorithms/:0:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"插入排序 func insertionSort(nums []int, left, right int) { for i := left + 1; i \u003c= right; i++ { j, temp := i-1, nums[i] for ; j \u003e= 0 \u0026\u0026 nums[j] \u003e temp; j-- { nums[j+1] = nums[j] } nums[j+1] = temp } } ","date":"2021-06-09","objectID":"/sort-algorithms/:1:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"快速排序 func quickSort(nums []int, left, right int) { if left \u003e= right { return } index := partition(nums, left, right) quickSort(nums, left, index-1) quickSort(nums, index+1, right) } func partition(nums []int, left, right int) int { // 随机选取一个元素作为基准 pos := rand.Intn(right-left+1) + left nums[left], nums[pos] = nums[pos], nums[left] i, j, pivot := left, right, nums[left] for i \u003c j { for i \u003c j \u0026\u0026 nums[j] \u003e= pivot { j-- } for i \u003c j \u0026\u0026 nums[i] \u003c= pivot { i++ } nums[i], nums[j] = nums[j], nums[i] } nums[i], nums[left] = nums[left], nums[i] return i } ","date":"2021-06-09","objectID":"/sort-algorithms/:2:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"归并排序 func mergeSort(nums []int) []int { if len(nums) \u003c= 1 { return nums } mid := len(nums) / 2 left, right := mergeSort(nums[:mid]), mergeSort(nums[mid:]) return mergeTwoArrays(left, right) } func mergeTwoArrays(left, right []int) []int { m, n := len(left), len(right) res := make([]int, m+n) i, j := 0, 0 for i \u003c m \u0026\u0026 j \u003c n { if left[i] \u003c right[j] { res[i+j] = left[i] i++ } else { res[i+j] = right[j] j++ } } for i \u003c m { res[i+j] = left[i] i++ } for j \u003c n { res[i+j] = right[j] j++ } return res } ","date":"2021-06-09","objectID":"/sort-algorithms/:3:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"堆排序 func heapSort(nums []int, left, right int) { for i := right / 2; i \u003e= 0; i-- { sink(nums, i, right) } for i := right; i \u003e left; i-- { nums[i], nums[left] = nums[left], nums[i] sink(nums, left, i-1) } } func sink(nums []int, root, end int) { for { child := 2*root + 1 if child \u003e end { return } if child \u003c end \u0026\u0026 nums[child] \u003c= nums[child+1] { child++ } if nums[root] \u003e nums[child] { return } nums[root], nums[child] = nums[child], nums[root] root = child } } ","date":"2021-06-09","objectID":"/sort-algorithms/:4:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"题目链接：https://leetcode-cn.com/problems/reverse-linked-list/ 写在前面：几乎所有链表题都有迭代和递归两种方法，并且两种方法都应该掌握，因为有时候面试官会要求使用某种特定的方法。 ","date":"2021-06-07","objectID":"/reverse-linked-list/:0:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["LeetCode"],"content":"迭代方法 由于单链表节点中只保留着下一个节点的信息，上一个节点的信息我们是不知道的，而翻转过程中我们需要将当前节点的next指向上一个节点，因此我们在遍历的过程中需要额外用一个指针告诉我们上一个节点；另外当我们修改了当前节点的next值后，我们将无法通过next来获取下一个节点，因此在修改next之前我们要用一个临时变量获取下一个节点。 通过上面分析，我们在代码实现中只需要注意两点即可： 遍历过程中用一个指针pre指向上一个节点 修改当前节点的next之前用一个临时变量获取下一个节点 经过上面的分析过后，不难写出下面代码： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { // 当链表为空或链表只有一个节点时，直接返回 if head == nil || head.Next == nil { return head } // pre 指向上一个节点，由于第一个节点的 next 将指向 nil，因此为了方便我们可以将 pre 初始化为 nil pre, curr := (*ListNode)(nil), head for curr != nil { // 临时变量 next 获取当前节点 curr 的下一个节点 next := curr.Next // 修改当前节点 curr 的 Next 值完成翻转 curr.Next = pre pre = curr curr = next } // 注意此时 curr 已经变成了 nil, pre 指向了原链表的最后一个节点(新链表的头结点) return pre } ","date":"2021-06-07","objectID":"/reverse-linked-list/:1:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["LeetCode"],"content":"递归方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { // 递归终止条件 if head == nil || head.Next == nil { return head } // 翻转以 head 的下一个节点为首的链表，并获取翻转后的链表的头结点 newHead := reverseList(head.Next) // 将 head 的下一个节点指向 head (将上图节点2指向节点1) head.Next.Next = head // 将 head 指向 nil (将上图节点1指向 nil) head.Next = nil // 返回新的头结点 newHead return newHead } ","date":"2021-06-07","objectID":"/reverse-linked-list/:2:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["CMU-15545"],"content":" 写在前面： 此实验可以直接在Mac(Intel chip)环境下运行，但是笔者今年年初入手的是Mac with M1 chip，经过测试后发现此实验并不能直接在M1芯片上运行(同样的还有MIT6.S081课程，最后只能转战Linux，所以购买Mac M1需谨慎。。) 由于国内网络的某些特殊原因，以下实验环境的搭建过程中需要用到科学上网，具体如何操作请自行研究。 ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:0:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["CMU-15545"],"content":"课程主页：CMU-15545 HOMEPAGE ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:1:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["CMU-15545"],"content":"实验环境：Ubuntu20.04(其余环境的搭建过程请参考Github中的README) 从https://github.com/cmu-db/bustub将实验代码fork到个人仓库，然后通过git clone将代码拷贝到本地。 在bustub目录下执行sudo build_support/packages.sh。 可能出现的错误：sudo: build_support/packages.sh command not found 解决办法：执行chmod +x build_support/packages.sh后再执行上面代码即可。 在bustub目录下依次执行以下命令： mkdir build cd build cmake .. make make check-tests 如果上述步骤没有错误，那么恭喜你，实验环境搭建成功，接下来就可以去完成实验了！ ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:2:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["Linux"],"content":" 本文旨在介绍Ubuntu下apt包管理工具的常用命令，在进行Linux开发时作为词典参考。 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:0:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt update sudo apt update 每次下载或更新本地软件时最好先执行apt update指令从服务器更新本地包仓库，从而获取最新版本的软件。 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:1:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt upgrade 将本地软件更新到仓库中最新版本，执行以下指令 # 更新所有软件 sudo apt upgrade 如果只想更新指定软件而非所有软件，执行以下指令 # 找出可更新的软件 apt list --upgradeable # 更新指定的软件 sudo apt upgrade \u003cpackage_1\u003e \u003cpackage_2\u003e ... 有些软件更新时需要输入y/n确认是否安装，如果不想输入的话可以在apt upgrade后面加-y Flag sudo apt upgrade -y 通常为了方便，我们将上面提到的apt update和apt upgrade写在一行 sudo apt update \u0026\u0026 sudo apt upgrade -y ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:2:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt install 安装指令软件，执行以下指令 sudo apt install \u003cpackage_1\u003e \u003cpackage_2\u003e ... 有些软件安装时需要输入y/n确认是否安装，如果不想输入的话可以在apt install后面加-y Flag sudo apt install -y \u003cpackage_1\u003e \u003cpackage_2\u003e ... 默认情况下apt install安装的软件都是最新版本的，如果想安装老版本的软件可以在软件名后面加=version # 安装 mysql-5.7 sudo apt install mysql-server=5.7 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:3:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt remove/purge 删除指定软件，执行以下指令 # apt remove只会删除软件本身，相关配置文件依旧保留 sudo apt remove \u003cpackage_1\u003e \u003cpackage_2\u003e ... # 如果执行了上面的指令后，想要删除相关配置文件，只需要执行下面这条指令即可 sudo apt autoremove # apt purge会将软件和配置信息一起删除 sudo apt purge \u003cpackage_1\u003e \u003cpackage_2\u003e ... ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:4:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt list sudo apt list apt list命令会列出所有的软件，包括仓库中的、已安装的和可更新的软件等，但是不建议直接执行该指令，最好搭配grep命令一起使用 sudo apt list | grep package_name 如果只想查看已下载的软件，执行以下指令 sudo apt list --installed 查看可更新的软件，执行以下指令 sudo apt list --upgradeable ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:5:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt show sudo apt show package_name apt show命令会列出软件的包依赖、版本、大小等等信息 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:6:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"}]