[{"categories":["MIT-6.S081"],"content":"LAB链接：https://pdos.csail.mit.edu/6.S081/2020/labs/util.html ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:0:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"sleep 作为第一个lab的第一个练习，主要用来给我们熟悉下代码框架和c语言的库函数等。 如果对进程调度和系统调用不熟悉的话请先看xv6 book第一章的第一节。 根据提示，查看user/echo.c, user/grep.c, user/rm.c源码了解如何获取并使用命令行参数(如果你熟悉c语言的话应该早已了解)，即main函数中传入了两个参数argc和argv，其中agrc表示命令行参数的个数(argument count)，argv表示命令行向量(argument vector)。例如有个可执行程序argstest，当你执行./argstest 1 2 3时，argc为4，argv为{\"argstest\", \"1\", \"2\", \"3\", NULL}，注意c语言中最后需要NULL作为终结符。 知道了命令行参数相关知识之后，根据sleep的参数个数argc应该为2(一个为sleep，另一个为用户指定的睡眠时间)，如果不为2，输出错误信息并退出。 通过atoi库函数将字符串转化为整数。其中atoi代表Ascii to Integer。 调用系统调用sleep。至于内核中如何实现系统调用sleep，可以查看kernel/sysproc.c中的sys_sleep函数；系统调用sleep从用户态跳到内核态的过程，可以查看user/usys.S中的相关汇编代码(本人太菜看不懂…) 最后将sleep写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" int main(int argc, char *argv[]) { if (argc != 2) { fprintf(2, \"Usage: sleep \u003cnumber\u003e\\n\"); exit(1); } int i = atoi(argv[1]); sleep(i); exit(0); } 运行sleep指令： $ make qemu ... init: starting sh $ sleep 10 (大概睡眠1秒) $ 执行./grade-lab-util sleep验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:1:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"pingpong 如果对I/O，文件描述符以及管道知识不熟悉的话请先看xv6 book第一章的第二、三节。 首先根据pingpong的使用，如果参数的个数大于1，直接输出错误信息并退出。 使用pipe()系统调用创建两个管道，将描述符存放在p1[2]和p2[2]，父进程向p1写，从p2读；子进程从p1读，向p2写。 父进程和子进程的读写顺序：不使用wait()的情况下父进程应该先写后读，子进程应该先读后写。 父进程不需要用到p1的读端和p2的写端，因此直接调用close()关闭，然后向p1写入一个字节内容，写完后关闭p1的写端，最后从p2读取内容，如果读取的字节数正好为1，则输出响应信息并关闭p2读端。子进程执行类似操作。 最后将pingpong写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" // Read and Write end of a pipe #define READ_END 0 #define WRITE_END 1 int main(int argc, char *argv[]) { if (argc \u003e 1) { fprintf(2, \"Usage: pingpong\\n\"); exit(1); } // Create two pipes: p1 and p2 // Child reads from p1, writes to p2 // Parent reads from p2, writes to p1 int p1[2], p2[2]; pipe(p1); pipe(p2); char buf[1]; if (fork() == 0) { // Child should read first close(p1[WRITE_END]); close(p2[READ_END]); if (read(p1[READ_END], buf, 1) == 1) { close(p1[READ_END]); printf(\"%d: received ping\\n\", getpid()); } // Child sends a byte to parent write(p2[WRITE_END], buf, 1); close(p2[WRITE_END]); } else { // Parent should write first close(p1[READ_END]); close(p2[WRITE_END]); // Parent sends a byte to child write(p1[WRITE_END], buf, 1); close(p1[WRITE_END]); if (read(p2[READ_END], buf, 1) == 1) { close(p2[READ_END]); printf(\"%d: received pong\\n\", getpid()); } } exit(0); } 运行pingpong指令： $ make qemu ... init: starting sh $ pingpong 4: received ping 3: received pong $ 运行./grade-lab-util pingpong验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:2:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"primes 首先通过阅读this page了解primes的工作原理：创建一个管道，父进程向管道写入从2到35的整数，子进程从管道读取数据后输出2，并且再次创建一个管道，向新创建的管道写入不是2的倍数的所有数字，依次递归进行下去，直到最后管道里没有任何数据。具体如下图： 根据primes的使用，如果参数的个数大于1，直接输出错误信息并退出。 main函数中，创建一个管道，父进程中先关闭管道的读端，然后向管道写入从2到35的整数，最后关闭管道的写端，注意此时需要执行wait()系统调用等待子进程执行完毕，否则父进程会在向管道写完数据后直接退出；子进程调用child()函数执行响应的操作。 child()函数中，首先关闭父进程中创建的管道pp的写端，从pp中读入一个int大小的数据，如果read()返回0，说明管道中没有数据，关闭pp的读端后直接返回；反之，输出从pp中读取到的第一个数i，随后创建当前进程的管道cp，在当前进程中关闭cp的读端后循环向cp中写入所有不是i的倍数，最后关闭pp的读端和cp的写端，调用wait()等待子进程；当前进程的子进程中，关闭pp的读端和cp的写端后，递归调用child()函数。 最后将primes写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\" // Read and Write end of a pipe #define READ_END 0 #define WRITE_END 1 // pp, cp stands for parent pipe and child pipe, respectively void child(int pp[]) { close(pp[WRITE_END]); int i; if (read(pp[READ_END], \u0026i, sizeof(i)) == 0) { close(pp[READ_END]); exit(0); } printf(\"prime %d\\n\", i); int num, cp[2]; pipe(cp); if (fork() == 0) { close(pp[READ_END]); close(cp[WRITE_END]); child(cp); } else { close(cp[READ_END]); while (read(pp[READ_END], \u0026num, sizeof(num)) != 0) { if (num % i != 0) { write(cp[WRITE_END], \u0026num, sizeof(num)); } } close(pp[READ_END]); close(cp[WRITE_END]); wait((int *) 0); } exit(0); } int main(int argc, char *argv[]) { if (argc \u003e 1) { fprintf(2, \"Usage: primes\\n\"); exit(1); } int p[2]; pipe(p); if (fork() == 0) { child(p); } else { close(p[READ_END]); // Feed the numbers 2 through 35 into the pipe for (int i = 2; i \u003c= 35; i++) { write(p[WRITE_END], \u0026i, sizeof(i)); } close(p[WRITE_END]); wait((int *) 0); } exit(0); } 运行primes指令： $ make qemu ... init: starting sh $ primes prime 2 prime 3 prime 5 prime 7 prime 11 prime 13 prime 17 prime 19 prime 23 prime 29 prime 31 $ 运行./grade-lab-util primes验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:3:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"find 如果对文件系统相关知识不熟悉的话请先看xv6 book第一章的第四节。 首先阅读user/ls.c源码了解如何读取文件目录信息以及判断文件类型，对ls.c的分析见下方代码中注释。 #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\" char* fmtname(char *path) { // DIRSIZ 在`kernel/fs.h`中定义 // #define DIRSIZ 14 static char buf[DIRSIZ+1]; char *p; // Find first character after last slash. for(p=path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; // 此时 p 为最后一个 \"/\" 后的字符串，即文件名。例如当路径为\"a/b/cd\"时，此时p为\"cd\" // Return blank-padded name. // 如果 p 的长度大于 DIRSIZ，直接返回 p if(strlen(p) \u003e= DIRSIZ) return p; // 如果 p 的长度小于 DIRSIZ，则用空格补齐 memmove(buf, p, strlen(p)); memset(buf+strlen(p), ' ', DIRSIZ-strlen(p)); return buf; } void ls(char *path) { char buf[512], *p; int fd; // 文件描述符 file descriptor // 定义位于 kernel/fs.h struct dirent de; // 目录项 directory entry // 定义位于 kernel/stat.h struct stat st; // 文件信息 file status // 调用 open() 打开路径 path 并返回相应的文件描述符 fd if((fd = open(path, 0)) \u003c 0){ fprintf(2, \"ls: cannot open %s\\n\", path); return; } // 调用 fstat 将 fd 对应的文件信息记录在 st 中 if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"ls: cannot stat %s\\n\", path); close(fd); return; } switch(st.type){ // st.type 为文件时直接返回即可 case T_FILE: printf(\"%s %d %d %l\\n\", fmtname(path), st.type, st.ino, st.size); break; // 当 st.type 为目录时 case T_DIR: // 此处只是限制了路径 path 的长度防止缓存溢出，不是很重要可以忽略 if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"ls: path too long\\n\"); break; } // 将 path 的内容拷贝到 buf strcpy(buf, path); // 指针 p 定位到 buf 的最后 p = buf+strlen(buf); // 在 buf 的最后位置添加 \"/\" *p++ = '/'; // 每次读取一个目录项 while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ // inum == 0 说明无效文件或目录 if(de.inum == 0) continue; // 将 de.name 拷贝到 p 中 memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, \u0026st) \u003c 0){ printf(\"ls: cannot stat %s\\n\", buf); continue; } printf(\"%s %d %d %d\\n\", fmtname(buf), st.type, st.ino, st.size); } break; } // 最后别忘了关闭文件描述符，否则浪费资源 close(fd); } int main(int argc, char *argv[]) { int i; // 如果 ls 后面没有参数，默认对当前目录 \".\" 执行 ls 命令 if(argc \u003c 2){ ls(\".\"); exit(0); } // 对 ls 后面的目录分别执行 ls 命令 for(i=1; i\u003cargc; i++) ls(argv[i]); exit(0); } 根据find的使用，参数的个数应该为3，分别是find、指定目录path、指定文件名filename。 递归调用find进入子目录寻找，注意不要进入\".“和”..“目录。 使用strcmp()函数判断两个字符串是否相等。 将find写入Makefile中的UPROGS。 最终代码如下： #include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"#include \"kernel/fs.h\" char* fmtname(char *path) { char *p; // Find first character after last slash for (p = path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; return p; } void find(char *path, char *filename) { char buf[512], *p; int fd; // file descriptor struct dirent de; // directory entry struct stat st; // file status if ((fd = open(path, 0)) \u003c 0) { fprintf(2, \"find: cannot open %s\\n\", path); return; } if (fstat(fd, \u0026st) \u003c 0) { fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } switch (st.type) { case T_FILE: if (strcmp(fmtname(path), filename) == 0) { printf(\"%s\\n\", path); } break; case T_DIR: if (strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf) { printf(\"find: path too long\\n\"); break; } // Add '/' strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while (read(fd, \u0026de, sizeof(de)) == sizeof(de)) { // Invalid directory if (de.inum == 0) { continue; } // Should not recurse into \".\" or \"..\" if (strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) { continue; } memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // Call find recursively find(buf, filename); } break; } close(fd); } int main(int argc, char *argv[]) { if (argc != 3) { fprintf(2, \"Usage: find \u003cpath\u003e \u003cfilename\u003e\\n\"); exit(1); } find(argv[1], argv[2]); exit(0); } 运行find指令： $ make qemu ... init: starting sh $ echo \u003e b $ mkdir a $ echo \u003e a/b $ find . b ./b ./a/b $ 运行./grade-lab-util find验证代码正确性。 ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:4:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":"xargs 如果不熟悉xargs指令可以查看xargs命令。 首先要知道，我们要实现的xargs每行只从标准输入流获取一个额外的命令参数。功能类似下图： 根据xargs的使用，参数的个数至少为2个，xargs、指定的命令command。 kernel/param.h中定义了最大参数个数MAXARG，创建一个大小为MAXARG的数组params用于存放命令参数，将argv中相应的参数拷贝到到params，注意留一个位置用于存放从标准输入读取的那个额外的命令参数。 从标准输入循环读取命令参数，当遇到\\n说明当前行的参数已经读取完毕，将其存放入params后创建一个子进程调用exec()执行对应的指令；如果标准输入中的参数读取完毕，则退出循环。注意父进程中调用wait()等待子进程结束。 最后将xargs写入Makefile中的UPROGS。 运行xargs指令： $ make qemu ... init: starting sh $ sh \u003c xargstest.sh $ $ $ $ $ $ hello hello hello $ $ 运行./grade-lab-util xargs验证代码正确性。 最后创建一个time.txt并写入一个数字表示你完成实验所花的时间，执行make grade，如果显示分数为100/100，说明实验全部做完啦~ ","date":"2021-06-14","objectID":"/mit-6.s081-lab1-util/:5:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081 lab1-util 详解","uri":"/mit-6.s081-lab1-util/"},{"categories":["MIT-6.S081"],"content":" 本人实验环境：Ubuntu20.04(其余环境请参考课程主页的配置教程) 更新apt源： sudo apt update \u0026\u0026 sudo apt upgrade 安装必要软件： sudo apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 下载并解压qemu： wget https://download.qemu.org/qemu-5.1.0.tar.xz tar xf qemu-5.1.0.tar.xz 编译qemu： cd qemu-5.1.0 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" # 此时可能出现下方错误 ERROR: pixman \u003e= 0.21.8 not present. Please install the pixman devel package. # 解决方法 sudo apt install libpixman-1-dev # 解决后继续执行下方命令 ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=\"riscv64-softmmu\" make sudo make install cd .. 安装riscv64-unknown-elf-gcc： sudo apt install gcc-riscv64-unknown-elf 下载课程代码： git clone git://g.csail.mit.edu/xv6-labs-2020 验证实验环境是否搭建完成： $ riscv64-unknown-elf-gcc --version riscv64-unknown-elf-gcc () 9.3.0 ... $ qemu-system-riscv64 --version QEMU emulator version 4.2.1 ... $ cd xv6-labs-2020 $ git checkout util $ make qemu ... init: starting sh $ 如果上面步骤都没有问题，说明你的实验环境已经成功搭建好了，最后按Ctrl-a再加x退出qemu ","date":"2021-06-12","objectID":"/mit-6.s081-lab-config/:0:0","tags":["MIT-6.S081","操作系统"],"title":"MIT-6.S081实验环境搭建","uri":"/mit-6.s081-lab-config/"},{"categories":["LeetCode"],"content":"题目链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/ 写在前面：几乎所有链表题都有迭代和递归两种方法，并且两种方法都应该掌握，因为有时候面试官会要求使用某种特定的方法。 ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:0:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"迭代方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head for { for i := 0; i \u003c k; i++ { // 不足K个直接返回 if right == nil { return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:1:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"递归方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { if head == nil || head.Next == nil || k == 1 { return head } p := head for i := 0; i \u003c k; i++ { // 不足K个直接返回 if p == nil { return head } p = p.Next } // 翻转 [head, p) 之间的K个节点 newHead := reverse(head, p) // 翻转后前K个节点的最后一个节点为 head，指向后续翻转返回的头节点 head.Next = reverseKGroup(p, k) // 返回新的头节点 return newHead } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:2:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"题目拓展 ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"不足K个也翻转 个人认为这个拓展反而让题目变简单了，在这里只给出迭代方法，递归方法可以类似得出。 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 不足K个也翻转 func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head for { for i := 0; i \u003c k; i++ { // 不足K个直接开始翻转并返回结果 if right == nil { pre.Next = reverseBetween(left, right) return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:1","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"从尾部开始计数 思路：先计算链表的长度，从而计算出从哪个节点开始翻转。也可以用栈做，但是那样空间复杂度就为O(n)了，这里就不给出栈的做法了，有兴趣的可以自己试试。 // 从尾部开始计数 func reverseKGroup(head *ListNode, k int) *ListNode { // 满足以下任何一个条件，直接返回 head if head == nil || head.Next == nil || k == 1 { return head } // n 用来记录链表的长度 p, n := head, 0 for p != nil { n++ p = p.Next } // 每次翻转需要保留上一次翻转的最后一个节点，为了让第一次翻转和后续的翻转操作统一这里我们使用虚拟节点 dummy := \u0026ListNode{Next: head} pre, left, right := dummy, head, head // 先让 pre, left, right 定位到第一次翻转的位置 for i := 0; i \u003c n%k; i++ { pre = pre.Next left = left.Next right = right.Next } for { for i := 0; i \u003c k; i++ { // 最后一次翻转时 right 会等于 nil，进入 if 内部进行最后一次翻转，并返回结果 if right == nil { pre.Next = reverseBetween(left, right) return dummy.Next } right = right.Next } // 上一次翻转的最后一个节点应该指向当前翻转后的头结点 pre.Next = reverseBetween(left, right) // pre 变为当前翻转后的最后一个节点，即 left pre = left // left 变为下一次翻转的头结点，即 right left = right } } // Reverse [head, tail) // 下方的函数类似单链表反转，不懂的话可以参考我的另一篇文章：https://www.peileiscott.top/reverse-linked-list/ func reverseBetween(head, tail *ListNode) *ListNode { if head == tail || head.Next == tail { return head } prev, curr := tail, head for curr != tail { next := curr.Next curr.Next = prev prev = curr curr = next } return prev } ","date":"2021-06-10","objectID":"/reverse-nodes-in-k-group/:3:2","tags":["LeetCode"],"title":"LeetCode面试高频题系列二：K个一组翻转链表","uri":"/reverse-nodes-in-k-group/"},{"categories":["LeetCode"],"content":"LeetCode相关题：https://leetcode-cn.com/problems/sort-an-array/ ","date":"2021-06-09","objectID":"/sort-algorithms/:0:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"插入排序 func insertionSort(nums []int, left, right int) { for i := left + 1; i \u003c= right; i++ { j, temp := i-1, nums[i] for ; j \u003e= 0 \u0026\u0026 nums[j] \u003e temp; j-- { nums[j+1] = nums[j] } nums[j+1] = temp } } ","date":"2021-06-09","objectID":"/sort-algorithms/:1:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"快速排序 func quickSort(nums []int, left, right int) { if left \u003e= right { return } index := partition(nums, left, right) quickSort(nums, left, index-1) quickSort(nums, index+1, right) } func partition(nums []int, left, right int) int { // 随机选取一个元素作为基准 pos := rand.Intn(right-left+1) + left nums[left], nums[pos] = nums[pos], nums[left] i, j, pivot := left, right, nums[left] for i \u003c j { for i \u003c j \u0026\u0026 nums[j] \u003e= pivot { j-- } for i \u003c j \u0026\u0026 nums[i] \u003c= pivot { i++ } nums[i], nums[j] = nums[j], nums[i] } nums[i], nums[left] = nums[left], nums[i] return i } ","date":"2021-06-09","objectID":"/sort-algorithms/:2:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"归并排序 func mergeSort(nums []int) []int { if len(nums) \u003c= 1 { return nums } mid := len(nums) / 2 left, right := mergeSort(nums[:mid]), mergeSort(nums[mid:]) return mergeTwoArrays(left, right) } func mergeTwoArrays(left, right []int) []int { m, n := len(left), len(right) res := make([]int, m+n) i, j := 0, 0 for i \u003c m \u0026\u0026 j \u003c n { if left[i] \u003c right[j] { res[i+j] = left[i] i++ } else { res[i+j] = right[j] j++ } } for i \u003c m { res[i+j] = left[i] i++ } for j \u003c n { res[i+j] = right[j] j++ } return res } ","date":"2021-06-09","objectID":"/sort-algorithms/:3:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"堆排序 func heapSort(nums []int, left, right int) { for i := right / 2; i \u003e= 0; i-- { sink(nums, i, right) } for i := right; i \u003e left; i-- { nums[i], nums[left] = nums[left], nums[i] sink(nums, left, i-1) } } func sink(nums []int, root, end int) { for { child := 2*root + 1 if child \u003e end { return } if child \u003c end \u0026\u0026 nums[child] \u003c= nums[child+1] { child++ } if nums[root] \u003e nums[child] { return } nums[root], nums[child] = nums[child], nums[root] root = child } } ","date":"2021-06-09","objectID":"/sort-algorithms/:4:0","tags":["LeetCode"],"title":"面试常考排序算法——Go语言实现","uri":"/sort-algorithms/"},{"categories":["LeetCode"],"content":"题目链接：https://leetcode-cn.com/problems/reverse-linked-list/ 写在前面：几乎所有链表题都有迭代和递归两种方法，并且两种方法都应该掌握，因为有时候面试官会要求使用某种特定的方法。 ","date":"2021-06-07","objectID":"/reverse-linked-list/:0:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["LeetCode"],"content":"迭代方法 由于单链表节点中只保留着下一个节点的信息，上一个节点的信息我们是不知道的，而翻转过程中我们需要将当前节点的next指向上一个节点，因此我们在遍历的过程中需要额外用一个指针告诉我们上一个节点；另外当我们修改了当前节点的next值后，我们将无法通过next来获取下一个节点，因此在修改next之前我们要用一个临时变量获取下一个节点。 通过上面分析，我们在代码实现中只需要注意两点即可： 遍历过程中用一个指针pre指向上一个节点 修改当前节点的next之前用一个临时变量获取下一个节点 经过上面的分析过后，不难写出下面代码： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { // 当链表为空或链表只有一个节点时，直接返回 if head == nil || head.Next == nil { return head } // pre 指向上一个节点，由于第一个节点的 next 将指向 nil，因此为了方便我们可以将 pre 初始化为 nil pre, curr := (*ListNode)(nil), head for curr != nil { // 临时变量 next 获取当前节点 curr 的下一个节点 next := curr.Next // 修改当前节点 curr 的 Next 值完成翻转 curr.Next = pre pre = curr curr = next } // 注意此时 curr 已经变成了 nil, pre 指向了原链表的最后一个节点(新链表的头结点) return pre } ","date":"2021-06-07","objectID":"/reverse-linked-list/:1:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["LeetCode"],"content":"递归方法 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { // 递归终止条件 if head == nil || head.Next == nil { return head } // 翻转以 head 的下一个节点为首的链表，并获取翻转后的链表的头结点 newHead := reverseList(head.Next) // 将 head 的下一个节点指向 head (将上图节点2指向节点1) head.Next.Next = head // 将 head 指向 nil (将上图节点1指向 nil) head.Next = nil // 返回新的头结点 newHead return newHead } ","date":"2021-06-07","objectID":"/reverse-linked-list/:2:0","tags":["LeetCode"],"title":"LeetCode面试高频题系列一：单链表翻转","uri":"/reverse-linked-list/"},{"categories":["CMU-15545"],"content":" 写在前面： 此实验可以直接在Mac(Intel chip)环境下运行，但是笔者今年年初入手的是Mac with M1 chip，经过测试后发现此实验并不能直接在M1芯片上运行(同样的还有MIT6.S081课程，最后只能转战Linux，所以购买Mac M1需谨慎。。) 由于国内网络的某些特殊原因，以下实验环境的搭建过程中需要用到科学上网，具体如何操作请自行研究。 ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:0:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["CMU-15545"],"content":"课程主页：CMU-15545 HOMEPAGE ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:1:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["CMU-15545"],"content":"实验环境：Ubuntu20.04(其余环境的搭建过程请参考Github中的README) 从https://github.com/cmu-db/bustub将实验代码fork到个人仓库，然后通过git clone将代码拷贝到本地。 在bustub目录下执行sudo build_support/packages.sh。 可能出现的错误：sudo: build_support/packages.sh command not found 解决办法：执行chmod +x build_support/packages.sh后再执行上面代码即可。 在bustub目录下依次执行以下命令： mkdir build cd build cmake .. make make check-tests 如果上述步骤没有错误，那么恭喜你，实验环境搭建成功，接下来就可以去完成实验了！ ","date":"2021-06-02","objectID":"/cmu-15545-lab-config/:2:0","tags":["CMU-15545","数据库"],"title":"CMU-15545 实验环境配置","uri":"/cmu-15545-lab-config/"},{"categories":["Linux"],"content":" 本文旨在介绍Ubuntu下apt包管理工具的常用命令，在进行Linux开发时作为词典参考。 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:0:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt update sudo apt update 每次下载或更新本地软件时最好先执行apt update指令从服务器更新本地包仓库，从而获取最新版本的软件。 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:1:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt upgrade 将本地软件更新到仓库中最新版本，执行以下指令 # 更新所有软件 sudo apt upgrade 如果只想更新指定软件而非所有软件，执行以下指令 # 找出可更新的软件 apt list --upgradeable # 更新指定的软件 sudo apt upgrade \u003cpackage_1\u003e \u003cpackage_2\u003e ... 有些软件更新时需要输入y/n确认是否安装，如果不想输入的话可以在apt upgrade后面加-y Flag sudo apt upgrade -y 通常为了方便，我们将上面提到的apt update和apt upgrade写在一行 sudo apt update \u0026\u0026 sudo apt upgrade -y ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:2:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt install 安装指令软件，执行以下指令 sudo apt install \u003cpackage_1\u003e \u003cpackage_2\u003e ... 有些软件安装时需要输入y/n确认是否安装，如果不想输入的话可以在apt install后面加-y Flag sudo apt install -y \u003cpackage_1\u003e \u003cpackage_2\u003e ... 默认情况下apt install安装的软件都是最新版本的，如果想安装老版本的软件可以在软件名后面加=version # 安装 mysql-5.7 sudo apt install mysql-server=5.7 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:3:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt remove/purge 删除指定软件，执行以下指令 # apt remove只会删除软件本身，相关配置文件依旧保留 sudo apt remove \u003cpackage_1\u003e \u003cpackage_2\u003e ... # 如果执行了上面的指令后，想要删除相关配置文件，只需要执行下面这条指令即可 sudo apt autoremove # apt purge会将软件和配置信息一起删除 sudo apt purge \u003cpackage_1\u003e \u003cpackage_2\u003e ... ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:4:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt list sudo apt list apt list命令会列出所有的软件，包括仓库中的、已安装的和可更新的软件等，但是不建议直接执行该指令，最好搭配grep命令一起使用 sudo apt list | grep package_name 如果只想查看已下载的软件，执行以下指令 sudo apt list --installed 查看可更新的软件，执行以下指令 sudo apt list --upgradeable ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:5:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"},{"categories":["Linux"],"content":"apt show sudo apt show package_name apt show命令会列出软件的包依赖、版本、大小等等信息 ","date":"2021-06-02","objectID":"/ubuntu-apt-command/:6:0","tags":["apt","Linux"],"title":"Ubuntu下包管理器apt常见命令","uri":"/ubuntu-apt-command/"}]